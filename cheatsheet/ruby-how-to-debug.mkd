### Temporaly memo

* upしたら、そのFrameに入る前の場所に戻った。だけど、再度そこの処理にsで入ったら、upした処理の後から継続された。つまり、今まで実行してきた処理には戻れなかった


### pry

# Socketのオブジェクトのwriteメソッドのドキュメントを見る
[14] pry(main)> ? Socket#write

# 実装を見る
[14] pry(main)> $ Socket#write



### Code Reading
* 動的
 - テスト実行にて(ケースを見るだけでもわかりやすい)
 - デバッガで
* 静的
 - Grep
 - ctags




### byebug

************************
Available commands:
backtrace  continue  down    exit    info  method  pry   reload   show    thread     var
break      delete    edit    finish  irb   next    ps    restart  skip    trace      where
catch      disable   enable  frame   kill  p       putl  save     source  undisplay
condition  display   eval    help    list  pp      quit  set      step    up
************************


## how to use

1. put "byebug" on first part of program
2. put breakpoint on proper point by "b" using "l", "v", "s" and confirming "info break"
3. save the condition of debugging if you want
4. next time, source the savefile and then start debug


## frequently use
* h[elp]: ex. h list
* set, show: setting and seeing about byebug environment
* restart
* enable, disable: on/off of backtrace
* save, source: to file of status of backtrace and so on
* bt[backtrace](=w[here]): display stack frames
* c[ontinue]
* n[ext][+-]?[ nnn]: step over
* l[ist]
* v[ar] l: local変数 -> インスタンス変数とか見たければ、"info"
* p, pp
* info: condition of process
* b[reak]
* c[ontinue][ nn]: nn行まで進む。使える！


## What's this?

* frame: refer to "up", "frame", "down", "finish"
 -> is it about stack frame??
* expression: refer to "putl", "display", "undisplay"
* skip, catch: なんか便利らしい。Exceptionがどーたら
* プログラム実行時にデバッグモードってできるよね？プログラム中にbyebugって入れなくて済むように


